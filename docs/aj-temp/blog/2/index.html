<!doctype html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<meta name="renderer" content="webkit" />
<meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" />
<!-- Vue 2.7.16 -->
<script src="https://g.alicdn.com/code/lib/vue/2.7.16/vue.min.js"></script> 
<link rel="icon" type="image/png" href="/asset/favicon.png"/>
    <link rel="stylesheet" href="/style/common.css"/>
    <link rel="stylesheet" href="/style/blog.css"/>
    <title>SqlMan's Blog: Why I so recommend &#39;SQL First&#39;?</title>
</head>

<body class="blog">
    <header class="top">
    <a class="github-fork-ribbon" href="https://github.com/lightweight-component/SqlMan" data-ribbon="Fork me on GitHub"
        title="Fork me on GitHub">Fork me on GitHub</a>
    <div>
        <nav>

            <div id="tools">
                <div class="locales-btn" onmousemove="document.querySelector('#tools menu').classList.add('show')"
                    onmouseleave="document.querySelector('#tools menu').classList.remove('show')">
                    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" viewBox="0 0 24 24" style="max-width: 42px;">
                        <path d="M0 0h24v24H0z" fill="none"></path>
                        <path
                            d=" M12.87 15.07l-2.54-2.51.03-.03c1.74-1.94 2.98-4.17 3.71-6.53H17V4h-7V2H8v2H1v1.99h11.17C11.5 7.92 10.44 9.75 9 11.35 8.07 10.32 7.3 9.19 6.69 8h-2c.73 1.63 1.73 3.17 2.98 4.56l-5.09 5.02L4 19l5-5 3.11 3.11.76-2.04zM18.5 10h-2L12 22h2l1.12-3h4.75L21 22h2l-4.5-12zm-2.62 7l1.62-4.33L19.12 17h-3.24z "
                            class="css-c4d79v"></path>
                    </svg>
                    <menu onmousemove="document.querySelector('#tools menu').classList.add('show')"
                        onmouseleave="document.querySelector('#tools menu').classList.remove('show')">
                        <ul>
                            <li><a href="https://sqlman.ajaxjs.com">English »</a></li>
                            <li><a href="https://sqlman.ajaxjs.com/cn-s">简体中文 »</a></li>
                            <li><a href="https://sqlman.ajaxjs.com/cn">正体中文 »</a></li>
                        </ul>
                    </menu>
                </div>
                <my-switch v-model="isDark"></my-switch>
            </div>
            <ul>
                <li><a href="/index.html">Home</a></li>
                <li><a href="/docs">Documents</a></li>
                <li><a href="/blog">Blog</a></li>
                <li><a href="https://github.com/lightweight-component/SqlMan">SourceCode</a></li>
            </ul>

        </nav>

        <div class="img">
            <img id="main-img" src="/asset/img.jpg" width="500" alt="" />
            <div>This has nothing to do with the "Dragon Ball";<br /> I just happen to be a fan of this comic.</div>
        </div>
        <div class="text">
            <h1>Welcome to SqlMan!</h1>
            <h2>A easy, small, straight forward Java CRUD Helper.</h2>
            <p>SqlMan is a lightweight wrapper over JDBC. It is NOT an ORM but follows a SQL-first approach. It allows
                you
                to use pure SQL with IF/forEach and pass Map parameters for queries or executions. The results you
                receive
                are either 'isOk' indicators and 'Map' or Java Bean object(s). SqlMan enables fast CRUD database
                operations
                with ZERO dependencies, except for the JDK.
            </p>

            <br />
            <br />
            <p>Similar libraries：Spring JDBC Template, Apache Commons DbUtils, Jdbi3.</p>

            <br />
            <br />
            <button class="primary" onclick="location.assign('/docs/quick-start')">Getting Start</button> 
            <button onclick="location.assign('https://github.com/lightweight-component/SqlMan')">Git Code</button>
            <div class="m">- Current version: v1.0 </div>
        </div>

    </div>
</header>
        <div class="content main">
            <h1>
                Blog
            </h1>
            <div class="list article">
                <h1>Why I so recommend &#39;SQL First&#39;?</h1>
                <h2>2024-12-25 by Frank Cheung</h2>
               <p>Looking at backend development as a whole, most of the work revolves around database development (commonly
referred to as &quot;CRUD Boy&quot;). How we interact with databases is closely related to our development experience.
The industry frequently discusses the &quot;object-relational impedance mismatch,&quot; which lies at the heart of the
issue: given that we have two different &quot;programming worldviews&quot;—a relational model database (SQL) and a
programming language (Java, C#, Go)—each with its own methodologies, use cases, and ways of thinking, how
can they coexist harmoniously and exchange information? Clearly, the &quot;impedance mismatch&quot; is not an easy
problem to solve.</p>
<p>Many backend developers try to avoid writing SQL by struggling with various ORM (Object-Relational Mapping)
solutions. To be frank, this isn't necessary. ORMs may seem to offer high development efficiency on the
surface, but in reality, they are just layers of abstraction—ultimately leading back to the SQL layer. ORMs,
in simple terms, transform one problem into another for resolution, completely bypassing SQL. However,
issues specific to databases, such as join queries, nested subqueries, and complex SQL logic, can hardly be
perfectly addressed within ORMs—or rather, they are not as straightforward or comfortable to write. Why go
through the trouble of using cumbersome ORMs when direct SQL is more flexible and efficient? ORMs might find
themselves stretched beyond their capabilities. These problems fall precisely into the domain where
relational databases excel. Transferring tasks best suited for relational databases to ORMs, which are less
adept at handling them, seems rather misguided. The object-oriented paradigm (of which ORMs are a
derivative) should perhaps temper its ambitions and focus on what it does best. Moreover, SQL itself is
sufficiently elegant and worthy of deep study.</p>
<p>The replacement of Hibernate by iBatis/MyBatis is a case in point, proving that writing SQL directly can be
more flexible and efficient (SQL First/SQL Centric). Later developments like MyBatis Plus's lambda syntax
somewhat revert to earlier approaches—similar to Microsoft's LINQ, which was widely adopted early on.</p>
<p>Of course, this doesn’t mean completely discarding the beneficial aspects of ORMs, such as:
<ul>
<li>
The &quot;object&quot; part of ORMs, which automatically converts a row of data (result set) into an object,
facilitating business code processing.
</li>
<li>
The readability concerns of SQL compared to programming languages, which depend on developer habits;
familiarity with SQL naturally enhances readability.
</li>
<li>
Single SQL statements cannot cover everything. Clearly, complex business logic requires collaboration
between SQL and Java.
</li>
</ul></p>
<p>Refer to: The Disaster of ORM (Object-Relational Mapping).</p>
<p>Considering these pros and cons, I boldly propose a clear, simple, and reusable JDBC solution aimed at
addressing CRUD (Create, Read, Update, Delete) issues within the realm of Java and JDBC. Defining the
interface between the two domains is crucial. In Java, developers often use the DAO (Data Access Object)
layer to solve this problem, which is exactly what we are discussing here.</p>

            </div>
        </div>

        <footer>
    SqlMan, a part of <a href="https://framework.ajaxjs.com" target="_blank">AJ-Framework</a> open source. Mail:
    frank@ajaxjs.com, visit <a href="https://blog.csdn.net/zhangxin09" target="_blank">my blog(In Chinese)</a>.
    <br />
    <br />
     Copyright © 2025 Frank Cheung. All rights reserved.
</footer>
</body>

</html>