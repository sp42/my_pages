<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
    <title>日志组件</title>
    <meta name="description" content="" />
    <meta name="keywords" content="" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="../../../common/inner.css" />
    <script src="../../../common/inner.js"></script>
</head>

<body>
    <h1>HTTP 请求组件</h1>
    <p>Apache HttpClient 是著名的 HTTP 客户端请求工具——现在我们模拟它打造一套简单小巧的请求工具库。
        该库的目的是，封装 Java 类库里面的 HttpURLConnection 对象来完成日常的 HTTP 请求，诸如 GET、HEAD、POST 等等。
    </p>

    <p>组件源码在：<span class="external-link">
            <span>↗</span>
        </span> <a
            href="https://gitee.com/sp42_admin/ajaxjs/tree/master/aj-backend/aj-framework/aj-framework/src/main/java/com/ajaxjs/util/logger"
            target="_blank">https://gitee.com/sp42_admin/ajaxjs/tree/master/aj-backend/aj-framework/aj-framework/src/main/java/com/ajaxjs/util/logger</a>。
    </p>

    <h2>发送 HTTP GET 请求</h2>
    <p>发送 HTTP GET 请求如下代码所示。</p>
    <pre class="code java-code">// 请求百度网站，返回网站的 HTML 内容
String html = Get.get("https://www.baidu.com").toString();</pre>
    <p>框架约定，所有 HTTP 请求返回特定的结果：ResponseEntity，包含了关于请求相关的设置和响应内容。典型地 toString() 返回响应内容的文本格式。ResponseEntity 是一个 Java
        Bean，字段如下。</p>
    <pre class="code java-code">public class ResponseEntity {
    /**
        * 返回响应文本结果
        */
    @Override
    public String toString() {
        return ResponseHandler.stream2Str(this).getResponseText();
    }

    /**
        * 连接对象
        */
    private HttpURLConnection connection;

    /**
        * 请求地址
        */
    private String url;

    /**
        * 请求方法
        */
    private String httpMethod;

    /**
        * 请求参数
        */
    private Map<String, Object> params;

    /**
        * 是否成功（http 200 即表示成功，4xx/500x 表示不成功）
        */
    private boolean isOk;

    /**
        * 程序异常，发生时间比 HTTP 请求靠前，例如非法网址，或者 dns 不存在的 UnknownHostException
        */
    private Exception ex;

    /**
        * HTTP 状态码
        */
    private Integer httpCode;

    /**
        * 响应消息字符串
        */
    private String responseText;

    /**
        * 结果的流
        */
    private InputStream in;
}</pre>

    <p>有时候我们需要获取响应的 HTTP 状态码，那么读取这个<code>ResponseEntity.getHttpCode()</code>就可以了。有的时候甚至不要读取内容，例如获取重定向地址，例如 HTTP HEAD
        请求（下面会讲）。</p>

    <h2>配置 HTTP 请求</h2>


    <p>一般情况下，需要在请求发起之前进行诸多的配置，除了 HTTP 方法、URL、参数这些之外，请求框架还应该提供对 HTTP Header 的配置。在 Java 中实际是围绕 HttpURLConnection 对象进行配置。
        怎么才可以灵活地配置呢？此处我们引入函数接口<code>Consumer&lt;HttpURLConnection&gt;</code>，即可添加头字段。重载的<code>get()</code> 方法如下。</p>
    <pre class="code java-code">/**
* GET 请求，返回文本内容
*
* @param url 请求目标地址
* @param fn  自定义 HTTP 头的时候可设置，可选的
* @return 响应的内容
*/
public static ResponseEntity get(String url, Consumer<HttpURLConnection> fn);

// 例子
ResponseEntity result = Get.get("http://abc.com", conn -> {
    conn.setRequestProperty("Content-Type", "application/json");
    conn.setRequestProperty("Authorization", "Bearer " + admin.getAccessToken());
});</pre>
    <p>框架提供常用的配置的 lambda，如指定 From POST 等等，参见 SetConnection 类。</p>

    <pre class="code java-code">/**
 * 为初始化 HTTP Connection 所准备的函数。该类不能创建实例
 * 
 * @author Frank Cheung<sp42@qq.com>
 *
 */
public abstract class SetConnection {
    /**
     * 设置 POST 方式
     */
    public final static Consumer<HttpURLConnection> SET_FORM_POST = conn -> conn.setRequestProperty("Content-type", "application/x-www-form-urlencoded;charset=utf-8");

    /**
     * 设置响应 JSON
     */
    public final static Consumer<HttpURLConnection> SET_JSON = conn -> conn.setRequestProperty("Content-type", "application/json");

    /**
     * 设置启动 GZip 请求
     */
    public final static Consumer<HttpURLConnection> SET_GIZPREQUEST = conn -> conn.addRequestProperty("Accept-Encoding", "gzip, deflate");
    ……
}</pre>
    <p>为了额外传参数来实施控制，还有其他静态方法返回<code>Consumer&lt;HttpURLConnection&gt;</code>。实际这些是<code>Consumer&lt;HttpURLConnection&gt;</code>的“高阶函数”。例如：
    </p>
    <pre class="code java-code">/**
    * 设置超时 （单位：秒）
    */
   public final static Consumer<HttpURLConnection> setTimeout(int timeout) {
       return conn -> conn.setConnectTimeout(timeout * 1000);
   }

   /**
    * 请求来源
    */
   public final static Consumer<HttpURLConnection> setReferer(String url) {
       return conn -> conn.addRequestProperty("Referer", url); // httpUrl.getHost()?
   }

   /**
    * 设置 cookies
    */
   public final static Consumer<HttpURLConnection> setCookies(Map<String, String> map) {
       return conn -> conn.addRequestProperty("Cookie", MapTool.join(map, ";"));
   }</pre>
    <p>只要都是<code>Consumer&lt;HttpURLConnection&gt;</code>类型，则可以链式调用，如<code>SET_FORM_POST.andThen(SET_JSON)</code>。</p>
    <h3>GZip</h3>
    <p>多数 HTTP 资源允许 GZip 压缩，那样传输效率更高。这时请求头须带上 GZip 打开的标识才可以，也就是说请求头加入了上面的<code>Accept-Encoding</code>字段，一般情况下服务器才会对内容进行
        GZip 压缩，否则就不压缩，原文输出。
        但有些网站是不管有没有这种请求都一概返回 GZip 的。如果有 GZip，服务器会在响应头中加入<code>Content-Encoding</code>的字段告诉我们的。</p>

    <h2>原理分析</h2>
    <p>有关原理的分析，请移步至博客文章：
        <span class="external-link">
            <span>↗</span>
        </span>
        <a href="https://zhangxin.blog.csdn.net/article/details/134070649" target="_blank">
            https://zhangxin.blog.csdn.net/article/details/134070649</a>。
    </p>
</body>

</html>